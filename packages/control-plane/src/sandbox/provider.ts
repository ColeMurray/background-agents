/**
 * Sandbox provider interface.
 *
 * Defines a pluggable abstraction for sandbox providers (Kubernetes, Docker, etc.)
 * enabling unit testing and future provider support.
 *
 * Kept as-is from the original -- this interface is provider-agnostic.
 */

/** Default sandbox lifetime in seconds (2 hours). */
export const DEFAULT_SANDBOX_TIMEOUT_SECONDS = 7200;

/**
 * Capabilities supported by a sandbox provider.
 */
export interface SandboxProviderCapabilities {
  /** Whether the provider supports filesystem snapshots */
  supportsSnapshots: boolean;
  /** Whether the provider supports restoring from snapshots */
  supportsRestore: boolean;
  /** Whether the provider supports pre-warming sandboxes */
  supportsWarm: boolean;
}

/**
 * Configuration for creating a new sandbox.
 */
export interface CreateSandboxConfig {
  /** Session ID for WebSocket routing */
  sessionId: string;
  /** Expected sandbox ID (generated by control plane) */
  sandboxId: string;
  /** Repository owner */
  repoOwner: string;
  /** Repository name */
  repoName: string;
  /** Control plane URL for sandbox callbacks */
  controlPlaneUrl: string;
  /** Authentication token for sandbox */
  sandboxAuthToken: string;
  /** LLM provider (e.g., "anthropic") */
  provider: string;
  /** LLM model (e.g., "claude-sonnet-4-5") */
  model: string;
  /** User-provided environment variables (repo secrets) */
  userEnvVars?: Record<string, string>;
  /** OpenCode session ID for resumption */
  opencodeSessionId?: string;
  /** Git user name for commits */
  gitUserName?: string;
  /** Git user email for commits */
  gitUserEmail?: string;
  /** Trace ID for correlation */
  traceId?: string;
  /** Request ID for correlation */
  requestId?: string;
}

/**
 * Result of creating a sandbox.
 */
export interface CreateSandboxResult {
  /** The sandbox ID (should match expected ID from config) */
  sandboxId: string;
  /** Provider's internal object ID (e.g., K8s pod name for future snapshot API) */
  providerObjectId?: string;
  /** Initial sandbox status */
  status: string;
  /** Creation timestamp */
  createdAt: number;
}

/**
 * Configuration for restoring a sandbox from a snapshot.
 */
export interface RestoreConfig {
  /** Snapshot image ID to restore from */
  snapshotImageId: string;
  /** Session ID for WebSocket routing */
  sessionId: string;
  /** Expected sandbox ID */
  sandboxId: string;
  /** Authentication token for sandbox */
  sandboxAuthToken: string;
  /** Control plane URL for sandbox callbacks */
  controlPlaneUrl: string;
  /** Repository owner */
  repoOwner: string;
  /** Repository name */
  repoName: string;
  /** LLM provider (e.g., "anthropic") */
  provider: string;
  /** LLM model (e.g., "claude-sonnet-4-5") */
  model: string;
  /** User-provided environment variables (repo secrets) */
  userEnvVars?: Record<string, string>;
  /** Sandbox lifetime in seconds. Defaults to DEFAULT_SANDBOX_TIMEOUT_SECONDS. */
  timeoutSeconds?: number;
  /** Trace ID for correlation */
  traceId?: string;
  /** Request ID for correlation */
  requestId?: string;
}

/**
 * Result of restoring a sandbox from a snapshot.
 */
export interface RestoreResult {
  /** Whether the restore succeeded */
  success: boolean;
  /** Sandbox ID if successful */
  sandboxId?: string;
  /** Provider's internal object ID */
  providerObjectId?: string;
  /** Error message if failed */
  error?: string;
}

/**
 * Configuration for taking a sandbox snapshot.
 */
export interface SnapshotConfig {
  /** Provider's internal object ID */
  providerObjectId: string;
  /** Session ID for context */
  sessionId: string;
  /** Reason for the snapshot */
  reason: string;
  /** Trace ID for correlation */
  traceId?: string;
  /** Request ID for correlation */
  requestId?: string;
}

/**
 * Result of taking a sandbox snapshot.
 */
export interface SnapshotResult {
  /** Whether the snapshot succeeded */
  success: boolean;
  /** Snapshot image ID if successful */
  imageId?: string;
  /** Error message if failed */
  error?: string;
}

/**
 * Error classification for circuit breaker decisions.
 */
export type SandboxErrorType = "transient" | "permanent";

/**
 * Custom error class for sandbox provider operations.
 */
export class SandboxProviderError extends Error {
  constructor(
    message: string,
    public readonly errorType: SandboxErrorType,
    public readonly cause?: Error,
  ) {
    super(message);
    this.name = "SandboxProviderError";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, SandboxProviderError);
    }
  }

  static isTransientStatus(status: number): boolean {
    return status === 502 || status === 503 || status === 504;
  }

  static isTransientNetworkError(error: unknown): boolean {
    if (error instanceof Error) {
      const message = error.message.toLowerCase();
      return (
        message.includes("fetch failed") ||
        message.includes("etimedout") ||
        message.includes("econnreset") ||
        message.includes("econnrefused") ||
        message.includes("network") ||
        message.includes("timeout")
      );
    }
    return false;
  }

  static fromFetchError(message: string, error: unknown, status?: number): SandboxProviderError {
    if (status !== undefined) {
      const errorType = SandboxProviderError.isTransientStatus(status) ? "transient" : "permanent";
      return new SandboxProviderError(
        message,
        errorType,
        error instanceof Error ? error : undefined,
      );
    }

    const errorType = SandboxProviderError.isTransientNetworkError(error)
      ? "transient"
      : "permanent";
    return new SandboxProviderError(message, errorType, error instanceof Error ? error : undefined);
  }
}

/**
 * Sandbox provider interface.
 */
export interface SandboxProvider {
  /** Provider name for logging and debugging */
  readonly name: string;
  /** Provider capabilities */
  readonly capabilities: SandboxProviderCapabilities;

  /**
   * Create a new sandbox.
   */
  createSandbox(config: CreateSandboxConfig): Promise<CreateSandboxResult>;

  /**
   * Restore a sandbox from a filesystem snapshot.
   * Only available if capabilities.supportsRestore is true.
   */
  restoreFromSnapshot?(config: RestoreConfig): Promise<RestoreResult>;

  /**
   * Take a filesystem snapshot of the sandbox.
   * Only available if capabilities.supportsSnapshots is true.
   */
  takeSnapshot?(config: SnapshotConfig): Promise<SnapshotResult>;
}
